%%%-------------------------------------------------------------------
%%% @author uer
%%% @copyright
%%% @doc
%%%
%%% @end
%%%-------------------------------------------------------------------
-module(hello).
-author("uer").
-export([double/1]).
-export([formatTemps/1]).
-export([cort_example/0]).
-export([varExamples/0]).


%% API
%% говорят, что рекорды - редкое гавно. Не использовать
-record(user, {id :: integer(),
  name :: string(),
  age :: integer(),
  city :: string(),
  jo :: string()
}).

-ifndef(PRINT_DEBUG).
-define(PRINT_DEBUG(Var), io:format("DEBUG: ~p.erl:~p - ~p~n", [?MODULE, ?LINE, Var])).
-endif.


%% кортежи - составной тип данных, который используется для хранения связанных элементов
%% могут содержать разные типы данных
cort_example() ->
  {1, 2, {3, ok}, red, green}.


%% Для достижения паралелльности, эрл использует модель акторов «процесс»
%% https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2
%% каждый актор можно представить как чувака, сидящего в комнате без окон и дверей и общающегося с другими акторами
%% через сообщения, который может принимать свои, сугобо локальные решения и порождать свои, сугубо локальные акторы.
%% Т.е. поделиться данными нельзя никак, кроме как явно передав сообщение другому актору. Все сообщения явные, каждое можно
%% перехватить и прочитать в целях отладки.

%% Отходя в сторону: термин «процесс» обычно используется, когда потоки исполнения не разделяют данных,
%% а термин «поток» – когда они так или иначе используют данные совместно. Потоки исполнения в
%% Erlang не разделяют данных, поэтому мы и называем из процессами.

%% Код эрла компайлится в байт код, и работает внутри виртуальной машины.
%% Т.е. можно запустить везде, где можно поднять машину.
%% Компоненты вм:
%%      инструменты для разработки (компилятор, отладчик, профайлер, система для тестирования, необязательный анализатор типов);
%%      • библиотека Открытой телекоммуникационной платформы ( Open Telecommunication Platform, или OTP);
%%      • веб-сервер;
%%      • богатые возможности и инструменты трассировки;

%% короч  менять переменные в эрле не получится
%% т.к. это логично с точки зрения математики
%% ф-ция вызванная с одними и теме же параметрами должна всегда возвращать один и тот же результат
%% это называется ссылочной прозрачностью
%% в некоторых  случаях  это правило принебреается, когда, например, надо  получать текущий день - т.е. каждый день значение
%% будет различным. Т.е. там, где можно столкнуться с проблемами реального мира эрл принебрегает правилами.
varExamples() ->
  % для целочесиелнного деления
  V = 4 div 2,

  ?PRINT_DEBUG({"this value is result of 4 div:", V}),

%% остаток от деления
  V2 = 5 rem 2,
  ?PRINT_DEBUG({"{this value is result of 5 rem3 : ~p~n", V2}),
%% переменная начинается с заглавной буквы
%% потому что есть тип данных - атом. Атом это литерал, константа,  значение которого - его имя
%% с атом cat уже больше ничего сделать не получится. Вот он только такой, какой он есть.
  A = cat,
  ?PRINT_DEBUG({"this value is atom: ~p~n", A}),
%% атом должен быть заключен в кавычки, если он начинается с чего угодно, кроме строчной буквы.
  A2 = '_@Cat',

  ?PRINT_DEBUG({"this value is atom: ~p~n", A2}),

%% атомы всегда живут в системе, пока программа не рухнет либо не будет заполнена вся таблица атомов
%% атом занимает 4 байта для 32бит систем и 8 для 64бит систем + длинна имени атома
%% т.е. не следует генерировтаь атомы динамически
%% атомы обычно используют для выражения или написания данных, с которыми он связан - обычно это кортеж


%% булева алгебра
%% and и or всегда вычиляют аргументы с двух сторон от опертора.
%% для более быстрых операторов стоит использовать andalso и orelse, которые вычисляют только правый аргумент
%% если он нужен для завершения вычисления

%% проверка на абсолютно точное равенство
  ?PRINT_DEBUG({"red =:= red", red =:= red}),
  ?PRINT_DEBUG({"red =:= green", red =:= green}),
  ?PRINT_DEBUG({"5 =:= 5.0]", 5 =:= 5.0}),

%% проверка на абсолютно точное НЕравенство
  ?PRINT_DEBUG({"red =/= red ", red =/= red}),
  ?PRINT_DEBUG({"red =/= green", red =/= green}),
  ?PRINT_DEBUG({"5 =/= 5.0", 5 =/= 5.0}),

%% проверка на простое равенство
  ?PRINT_DEBUG({"red == red", red == red}),
  ?PRINT_DEBUG({"red == green", red == green}),
  ?PRINT_DEBUG({"5 == 5.0]", 5 == 5.0}),

%% проверка на простое НЕравенство
  ?PRINT_DEBUG({"red /= red ~p\n", red /= red}),
  ?PRINT_DEBUG({"red /= green ~p\n", red /= green}),
  ?PRINT_DEBUG({"5 /= 5.0 ~p\n", 5 /= 5.0}),
%% с больше или меньше, больше или равно, меньше или равно, слава богу, все в порядке в плане синтаксиса.
%% сравнивать, в отличие от арифтетических операций, можно что угодно с чем угодно
  ?PRINT_DEBUG({"5 > 6", 5 > 6}),
  ?PRINT_DEBUG({"true > 0", true > 0}),
  ?PRINT_DEBUG({"true < 0", true < 0}),
  ?PRINT_DEBUG({"red == 3", red == 3}),
  ?PRINT_DEBUG({"cat > 42", cat > 42}),
%% true / false - это, кстати, атомы
  ?PRINT_DEBUG({"true, false", true, false}),
%% вообще порядок сравнения типов данных в эрланге таков
%% числа < атомы < ссылочные значения < функции < порты < идентификаторы процессов < кортежи < списки < двоичные данныеъ
%% т.е. как видно, двоичные числа больше всех

%% кортежи
%% кортеж, по всей видимости, не изменяем и может содержать значения любых типов

%% Если нужна только одна координата из кортежа, можно сделать так:
%% Ща очень важно. Про сопоставление с образцом(паттерн матчинг)

  Point = {4, 5},

  {X, Y} = Point,
  ?PRINT_DEBUG({"{X, Y} = Point", {X, Y}}),

  ?PRINT_DEBUG({"{x, _}", {X, _} = Point}),

  ?PRINT_DEBUG({"X", X}),

  %% Антонимная пермененая _
  %% {_, _} = {3, 4, 8} - работать не будет
  %% {_, _} = {4, 5}    - работать будет

  ?PRINT_DEBUG({" {_, _} = {3, 4, _},", {_, _} = {3, 4}}),
%% Что тут произошло?
%% мы не можем присваивать другие значение уже созданным переменным, но
%% мы можем присваивать уже созданным переменным одинаковые значения. Т.е. если Ы = 5,
%% и мы потом снова сделаем Ы = 5 - это будет работать. (Ы = 6 уже не будет)
%% А это значит, что мы можем использовать это свойсво для сравнения данных с образцом данных
%% ниже наиболее наглядый пример для кортежей, то что будет использоваться наиболее часто:
  PointHome = {6, 7},

  CatPointHome = {cat, PointHome, "meow"},
  DogPointHome = {dog, PointHome, "wooof"},

%% возникнет исключение, перехватываем его
  Exception = (catch CatPointHome = DogPointHome),

  ?PRINT_DEBUG({"CatPoint = DogPoint", Exception}),

%% но мы можем понять при помощи сравнения и атома, к какому типу можно отнести наш кортеж
%% кортеж, который содержит атом, называется кортеж с тегом
  ?PRINT_DEBUG({"{cat, _} = CatPointHome", {cat, _, _} = CatPointHome}),


%% списки
%% списки - типа рабочая лошадка всех функциональных яп
%% списки могут содержать вообще что угодно
  M = [1, 2, 3, {numbers, [4, 5.6], 5.34}, atom],
  erlang:display(M),
%% Забавное - строка
  Str = [97, 98, 99],
%% erl будет печатать числа как строки, если все они могут представлять собой буквы
  %% если хоть одно число не будет - то эрл напечатает все как числа
  %% строки в эрл - это списки
  erlang:display(Str),
%% чтобы склеить списко надо использовать ++ , для удаления элемента --
%% эти операторы имеют правую ассоциативность, это значит, что несколько идущих подряд операций -- ++ будут выполеннны справа налево
  Joined = [1, 2, 3] ++ [4, 5, 6],
  erlang:display(Joined),
  %% сперва удаляется 3, 5, 6 из 4,6 - остается 4, и потом  4 удаляется из Joined и в конце выполнится выражение за скобками
  Subtracted = (Joined -- [4, 6]  -- [3, 5, 6]) ++ [11, 12],
  Subtracted = Subtracted,

  erlang:display(Subtracted),

%% первый эелемнт списка называется головой и остаток - хвостом
%% почти все программы работают с головой списка и наиболее простой способ отделить голову от списка это паттерн матчинг

  %% добавление элемента
  NewList = [head | Subtracted],

  erlang:display(NewList),
  %% разделение на голову и хвост
  [Head | Tile] = NewList,

  erlang:display(Head),
  erlang:display(Tile),
  %% создание списка
  %% список можно строить на основе конструктора |
  %% таким образом список будет определн рекурсивно. Так работают генераторы списков
  L = [1 | [2 | [5 | [atom, 4]]]],
  ?PRINT_DEBUG(" L = [1 | [2 | [5 | [atom, 4]]]],"),
  erlang:display(L),
  %% в эрланг  есть встроенные ф-ции (BIFs) которые нельзя написать на чистом эрланге
  %% по этому они написанны на С. Некторые из  них все таки было бы можно написать на эрланге
  %% но они были переписанны на С из-за соображений скорости
  %% например, ф-ция length(список), которая возвращает длинну списка
  ?PRINT_DEBUG("length(L)"),
  erlang:display(length(L))
.

%% две ф-ции с одинаковым имененем, но разной сигнатурой являются разными ф-циями
%% по этой причине, можно делать несколько одинаковых ф-ций для разных случаев сигнатур
formatTemps([]) ->
  % для пустого списка вывод не производится
  ok;
formatTemps([City | Rest]) ->
  print_temp(convert_to_celsius(City)),
  formatTemps(Rest)
.

% Конвертация не нужна
%% Т.е. в данном случае происходит следующее:
%% если нам пришли градусы с на вход, значит, конвертация не нужна, т.к. входящий кортеж
%% по паттерн матчингу с атомом "с" считается градусами цельсия
%% по этой причине делам еще одну ф-цию, которая будет срабатывать только тогда, когда
%% на вход придут градусы по Фаренгейту "f"
convert_to_celsius({Name, {c, Temp}}) ->
  {Name, {c, Temp}};
convert_to_celsius({Name, {f, Temp}}) ->
  {Name, {c, (Temp - 32) * 5 / 9}}
.


print_temp({Name, {c, Temp}}) ->
  io:format("~-15w ~w c~n", [Name, Temp]).



double(X) ->
  2 * X.

